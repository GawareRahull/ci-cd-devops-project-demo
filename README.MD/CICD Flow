# ğŸš€ CI/CD DevOps Project Demo

## ğŸ“Œ Project Overview

This repository contains a complete **CI/CD pipeline** implementation for a **Node.js application** using **Jenkins**, **Docker**, and deployed on **AWS EC2**.

Any change pushed to this GitHub repository triggers the Jenkins pipeline, which builds a Docker image, pushes it to DockerHub, and deploys the application container on AWS EC2.

---

## Architecture Diagram

![CI/CD Architecture](https://raw.githubusercontent.com/GawareRahull/ci-cd-devops-project-demo/main/architecture-diagram.png)

The above diagram shows how code flows from the developer to production:
1. Developer pushes code to GitHub.
2. GitHub triggers the Jenkins job.
3. Jenkins builds and pushes a Docker image.
4. Jenkins deploys the container on the EC2 instance.
5. Application is served to users via public IP and port.

---

## ğŸ›  Technologies Used

| Layer | Technology |
|-------|------------|
| Source Control | GitHub |
| CI/CD Tool | Jenkins |
| Containerization | Docker |
| Hosting | AWS EC2 (Ubuntu) |
| Application | Node.js |

---

## ğŸ”„ CI/CD Pipeline Flow

### 1ï¸âƒ£ Code Versioning

- The Node.js application code is stored in GitHub.
- Jenkins monitors the `main` branch for changes.

### 2ï¸âƒ£ Checkout and Build

Jenkins pulls the latest code:

Then builds a Docker image using the `Dockerfile`.

---

### 3ï¸âƒ£ Docker Image Build

Docker builds the image:

docker build -t rahulgaware/ci-cd-devops-demo .

Jenkins uses this image to run the app.

4ï¸âƒ£ Docker Login

Jenkins logs in to DockerHub using stored credentials.

5ï¸âƒ£ Docker Push

The built image is pushed to DockerHub.

6ï¸âƒ£ Deployment

Before deploying new container, Jenkins:

Stops old container (if running).

Removes old container.

Then runs the new container:

docker run -d -p 8081:3000 --name ci-container rahulgaware/ci-cd-devops-demo


The application is now accessible at:

http://<EC2_PUBLIC_IP>:8081

ğŸ“Œ How to Access the Application

After successful deployment, open in browser:

http://<EC2-IP>:8081

âš ï¸ Problem Faced During Development

Issue:
Container failed due to missing index.js file.

Root Cause:
Docker image was built successfully but application failed at runtime.

Solution:
Added health check step in Jenkins pipeline:

sleep 10
curl -f http://localhost:8081 || exit 1


Now pipeline fails if application is not running.

ğŸ” Security Configuration

EC2 Security Group allows port 8081

SSH access restricted to specific IP

ğŸš€ Future Improvements

Push Docker image to DockerHub

Add Nginx reverse proxy

Add HTTPS using Let's Encrypt

Implement Blue-Green deployment

Deploy using Kubernetes

Add SonarQube integration

Add Slack notifications

ğŸ“Š Project Learning Outcomes

Implemented automated CI/CD pipeline

Containerized Node.js application

Deployed on AWS EC2

Understood difference between build-time and runtime errors

Implemented application health check

ğŸ† Author

Rahul Gaware
DevOps Engineer

